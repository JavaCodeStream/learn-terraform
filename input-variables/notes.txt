Input Variables in Terraform
==============================

- It not best practice to hard code attribute values directly within the resource blocks in Terraform
config files as it limits the re-usability of the code which defeats the purpose of IaC.
- We need to make sure the same config code can be used again and again to deploy resources based on 
set of input variables that can be provided during the execution time.
- that is where Input Variables come into picture.

- We can keep the input variables in the same main.tf file along with the resource blocks BUT 
Best practice is to keep all of the input variables code in a single tf file variables.tf

- Input variables are just like resource blocks consists of blocks and arguments.

- syntax: 
    - keyword -> variable followed by the variable name.
    - The label after the variable keyword is a name for the variable, which must 
    be unique among all variables in the same module.
    - The name of a variable can be any valid identifier except the following: source, 
    version, providers, count, for_each, lifecycle, depends_on, 
    locals (reserved for meta-arguments)
    - within the variable block, we can provide a default value to each variable. this is an optional
    attribute but it is a quick and simple way to assign variables.
    - to use these variables, var.<name_of_variable> within respective resource block
    - NOTE: input variables does not accept any expression like: 
    variable "filename" {
        default = "${path.module}/my_local_file.txt"
    }

    for that we need to use like:

    resource "local_file" "my-local-file" {
        filename = "${path.module}/${var.filename}"
        content  = var.content
    }


variables.tf
--------------
variable "filename" {
  default = "my_local_file.txt"
}

variable "content" {
  default = "We love Pets!!"
}

variable "prefix" {
  default = "Mrs"
}

variable "separator" {
  default = "."
}

variable "length" {
  default = "1"
}


main.tf
------------------------------------------
resource "local_file" "my-local-file" {
  filename = var.filename
  content  = var.content
}

resource "random_pet" "my-pet" {
  prefix    = var.prefix
  separator = var.separator
  length    = var.filename
}



Similarly creating aws resource for EC2 instance:
--------------------------------------------------

main.tf
--------
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 4.16"
    }
  }

  required_version = ">= 1.2.0"
}

provider "aws" {
  region  = "us-west-2"
}

resource "aws_instance" "app_server" {
  ami           = var.ami
  instance_type = var.instance_type

  tags = {
    Name = "ExampleAppServerInstance"
  }
}

variables.tf
--------------
variable "ami" {
  default = "ami-830c94e3"
}

variable "instance_type" {
  default = "t2.micro"
}


Arguments of input variables
=================================
- accepts 6 arguments.
  - default - A default value which then makes the variable optional.
  - type - This argument specifies what value types are accepted for the variable.
  - description - This specifies the input variable's documentation.
  - validation - A block to define validation rules, usually in addition to type constraints.
  - sensitive - Limits Terraform UI output when the variable is used in configuration.
  - nullable - Specify if the variable can be null within the module.
 and description

variable "filename" {
    type = "string"
    description = "path of local file"
    default = "my_local_file.txt"
}


Default values
---------------
- If present, the default value will be used if no value is set when calling the 
module or running Terraform. 
- he default argument requires a literal value and cannot reference other 
objects in the configuration.
ex: below is not allowed:
    variable "filename" {
        default = "${path.module}/my_local_file.txt"
    }



Types
=========================
- allows you to restrict the type of value that will be accepted as the value for a variable.
- If no type constraint is set then a value of any type is accepted.

- While type constraints are optional, they allow Terraform to return a helpful error 
message if the wrong type is used.

type keywords are:

string
number
bool

complex types such as collections:

list(<TYPE>)
set(<TYPE>)
map(<TYPE>)
object({<ATTR NAME> = <TYPE>, ... })
tuple([<TYPE>, ...])



Using Variables in Terraform
=================================

